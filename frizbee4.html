<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dog Park Adventure</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            font-family: Arial, sans-serif;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            font-family: Arial, sans-serif;
        }
        #score-container {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            font-family: Arial, sans-serif;
        }
        #score {
            font-size: 20px;
            margin-bottom: 5px;
        }
        #with-dog {
            font-size: 16px;
            margin-bottom: 5px;
        }
        #color-counts {
            font-size: 14px;
            line-height: 1.4;
        }
        .score-popup {
            position: absolute;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px #000000;
            animation: floatUp 1s forwards;
        }
        @keyframes floatUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-50px); opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="instructions">
        W: Move Forward | S: Move Backward | A/D: Turn Left/Right | SPACE: Jump | Right Mouse Button: Look Around | E: Return Items
    </div>
    <div id="score-container">
        <div id="score">Score: 0</div>
        <div id="with-dog">With Dog: 0/5</div>
        <div id="color-counts">Carrying: None</div>
    </div>
    <div id="loading">Loading...</div>
    <audio id="backgroundMusic" loop>
        <source src="https://assets.mixkit.co/music/preview/mixkit-relaxing-guitar-melody-1234.mp3" type="audio/mpeg">
    </audio>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script>
        // Scene setup - creates the 3D environment
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Sky blue background
        
        // Camera setup - perspective camera with 75Â° field of view
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 10, 15); // Position camera above and behind the dog
        
        // Renderer setup - WebGL renderer with antialiasing
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // Enable shadows
        document.body.appendChild(renderer.domElement);

        // Game state variables
        let score = 0; // Player's score
        let withDogCount = 0; // Number of items currently carried by the dog
        const maxWithDog = 5; // Maximum items the dog can carry
        const colorCounts = {}; // Tracks count of each color being carried
        const scoreElement = document.getElementById('score'); // Score display element
        const withDogElement = document.getElementById('with-dog'); // Carried items count element
        const colorCountsElement = document.getElementById('color-counts'); // Color counts display
        let gameLoaded = false; // Flag to check if game assets are loaded
        const loadingText = document.getElementById('loading'); // Loading text element
        const parkRadius = 60; // Radius of the circular park
        // Boundary box for collision detection
        const parkBoundary = new THREE.Box3(
            new THREE.Vector3(-parkRadius, -1, -parkRadius),
            new THREE.Vector3(parkRadius, 20, parkRadius)
        );
        
        // Objects collections
        const obstacles = []; // Collidable objects in the scene
        const collisionObjects = []; // All objects that can collide
        const npcs = []; // Array of NPCs in the game
        const projectiles = []; // Array of thrown projectiles
        const carriedProjectiles = []; // Array of projectiles carried by dog
        const flowerPatches = []; // Flower patches in the park
        const dustbins = []; // Dustbins in the park
        let dog; // The player's dog character
        let minNPCs = 3; // Minimum number of NPCs
        let maxNPCs = 10; // Maximum number of NPCs
        let currentNPCs = 5; // Current number of NPCs

        // Define NPC colors including white for trash
        const npcColors = [
            0x4682B4, // Blue
            0x32CD32, // Green
            0xFF6347, // Red
            0x9370DB, // Purple
            0xFFD700, // Gold
            0x40E0D0, // Turquoise
            0x7CFC00, // Lawn Green
            0x00FFFF, // Cyan
            0xFFFFFF  // White (for trash)
        ];
        
        // Color names mapping for display
        const colorNames = {
            0x4682B4: "blue",
            0x32CD32: "green",
            0xFF6347: "red",
            0x9370DB: "purple",
            0xFFD700: "gold",
            0x40E0D0: "turquoise",
            0x7CFC00: "lawn green",
            0x00FFFF: "cyan",
            0xFFFFFF: "trash"
        };
        
        // Initialize color counts for all possible colors
        npcColors.forEach(color => {
            colorCounts[color] = 0;
        });

        // Update the color counts display with formatted text
        function updateColorCounts() {
            let text = "Carrying:<br>";
            let hasItems = false;
            
            // Create a line for each color being carried
            for (const color in colorCounts) {
                if (colorCounts[color] > 0) {
                    const colorName = colorNames[color] || "unknown";
                    text += `<span style="color: #${color.toString(16).padStart(6, '0')}">${colorName} - ${colorCounts[color]}</span><br>`;
                    hasItems = true;
                }
            }
            
            if (!hasItems) text += "None";
            colorCountsElement.innerHTML = text;
        }

        // Audio setup for background music
        const bgMusic = document.getElementById('backgroundMusic');
        bgMusic.volume = 0.3; // Set volume to 30%
        
        // Enable music on first user interaction (required by browser autoplay policies)
        function enableMusic() {
            bgMusic.play().catch(e => console.log("Audio play failed:", e));
            document.removeEventListener('click', enableMusic);
        }
        document.addEventListener('click', enableMusic);

        // Camera orbit controls - allows looking around with right mouse button
        let isRightMouseDown = false; // Track if right mouse button is pressed
        let previousMouseX = 0; // Previous mouse X position
        let previousMouseY = 0; // Previous mouse Y position
        let cameraAngleX = 0; // Horizontal camera angle
        let cameraAngleY = 0; // Vertical camera angle
        const cameraDistance = 15; // Distance from dog to camera
        const cameraHeight = 5; // Height of camera above dog
        
        // Update camera position based on angles and dog position
        function updateCameraPosition() {
            const offset = new THREE.Vector3(0, cameraHeight, -cameraDistance);
            offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraAngleX); // Apply horizontal rotation
            const verticalAxis = new THREE.Vector3(
                Math.sin(cameraAngleX),
                0,
                Math.cos(cameraAngleX)
            );
            offset.applyAxisAngle(verticalAxis, cameraAngleY); // Apply vertical rotation
            camera.position.copy(dog.position).add(offset); // Position camera relative to dog
            camera.lookAt(dog.position); // Make camera look at dog
        }
        
        // Mouse event handlers for camera control
        renderer.domElement.addEventListener('mousedown', (event) => {
            if (event.button === 2) { // Right mouse button
                isRightMouseDown = true;
                previousMouseX = event.clientX;
                previousMouseY = event.clientY;
                renderer.domElement.style.cursor = 'grabbing';
            }
        });
        
        renderer.domElement.addEventListener('mouseup', (event) => {
            if (event.button === 2) { // Right mouse button released
                isRightMouseDown = false;
                renderer.domElement.style.cursor = 'grab';
            }
        });
        
        renderer.domElement.addEventListener('mousemove', (event) => {
            if (isRightMouseDown && gameLoaded) {
                const deltaX = event.clientX - previousMouseX;
                const deltaY = event.clientY - previousMouseY;
                cameraAngleX -= deltaX * 0.005; // Update horizontal angle
                cameraAngleY = Math.max(-Math.PI/3, Math.min(Math.PI/3, cameraAngleY - deltaY * 0.005)); // Update vertical angle with limits
                updateCameraPosition();
                previousMouseX = event.clientX;
                previousMouseY = event.clientY;
            }
        });
        
        // Prevent context menu on right click
        renderer.domElement.addEventListener('contextmenu', (event) => event.preventDefault());

        // Lighting setup
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // Soft overall light
        scene.add(ambientLight);
        
        // Main directional light (sun-like)
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10); // Position the light
        directionalLight.castShadow = true; // Enable shadows
        directionalLight.shadow.mapSize.width = 2048; // Shadow quality
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // Create circular park with walking tracks
        function createPark() {
            // Main ground - large green circle
            const groundGeometry = new THREE.CircleGeometry(parkRadius, 64);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4CAF50, // Green color
                side: THREE.DoubleSide
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2; // Rotate to be horizontal
            ground.receiveShadow = true; // Ground receives shadows
            scene.add(ground);
            
            // Outer walking track - brown ring around the edge
            const outerTrackGeometry = new THREE.RingGeometry(parkRadius - 5, parkRadius, 64);
            const outerTrackMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513, // Brown color
                side: THREE.DoubleSide
            });
            const outerTrack = new THREE.Mesh(outerTrackGeometry, outerTrackMaterial);
            outerTrack.rotation.x = -Math.PI / 2;
            outerTrack.receiveShadow = true;
            scene.add(outerTrack);
            
            // + shaped walking tracks in the center
            const trackWidth = 3;
            const trackLength = parkRadius * 1.8;
            
            // Horizontal track
            const horizontalTrackGeometry = new THREE.PlaneGeometry(trackLength, trackWidth);
            const horizontalTrackMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const horizontalTrack = new THREE.Mesh(horizontalTrackGeometry, horizontalTrackMaterial);
            horizontalTrack.rotation.x = -Math.PI / 2;
            horizontalTrack.position.y = 0.01; // Slightly above ground to prevent z-fighting
            scene.add(horizontalTrack);
            
            // Vertical track
            const verticalTrackGeometry = new THREE.PlaneGeometry(trackWidth, trackLength);
            const verticalTrackMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const verticalTrack = new THREE.Mesh(verticalTrackGeometry, verticalTrackMaterial);
            verticalTrack.rotation.x = -Math.PI / 2;
            verticalTrack.position.y = 0.01;
            scene.add(verticalTrack);
            
            // Inner circle (center meeting area)
            const innerCircleRadius = 10;
            const innerCircleGeometry = new THREE.CircleGeometry(innerCircleRadius, 64);
            const innerCircleMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                side: THREE.DoubleSide
            });
            const innerCircle = new THREE.Mesh(innerCircleGeometry, innerCircleMaterial);
            innerCircle.rotation.x = -Math.PI / 2;
            innerCircle.position.y = 0.01;
            scene.add(innerCircle);
            
            // Fountain in center - decorative element
            const fountainBaseGeometry = new THREE.CylinderGeometry(3, 4, 0.5, 32);
            const fountainBaseMaterial = new THREE.MeshStandardMaterial({ color: 0xAAAAAA });
            const fountainBase = new THREE.Mesh(fountainBaseGeometry, fountainBaseMaterial);
            fountainBase.position.set(0, 0.25, 0);
            fountainBase.castShadow = true;
            fountainBase.receiveShadow = true;
            
            const fountainPillarGeometry = new THREE.CylinderGeometry(1, 1, 3, 32);
            const fountainPillarMaterial = new THREE.MeshStandardMaterial({ color: 0xDDDDDD });
            const fountainPillar = new THREE.Mesh(fountainPillarGeometry, fountainPillarMaterial);
            fountainPillar.position.set(0, 2, 0);
            
            const fountainTopGeometry = new THREE.CylinderGeometry(2, 0, 1, 32);
            const fountainTopMaterial = new THREE.MeshStandardMaterial({ color: 0xCCCCCC });
            const fountainTop = new THREE.Mesh(fountainTopGeometry, fountainTopMaterial);
            fountainTop.position.set(0, 3.5, 0);
            
            const fountain = new THREE.Group();
            fountain.add(fountainBase, fountainPillar, fountainTop);
            scene.add(fountain);
            
            // Add collision box for fountain
            const fountainCollision = new THREE.Box3().setFromObject(fountain);
            obstacles.push(fountainCollision);
            collisionObjects.push(fountain);
        }

        // Create flower patches around the park
        function createFlowerPatches() {
            const patchSize = 3.5; // Size of each flower patch
            const patchesCount = 8; // Number of flower patches
            
            for (let i = 0; i < patchesCount; i++) {
                let x, z, attempts = 0;
                const angle = (i / patchesCount) * Math.PI * 2; // Evenly spaced around circle
                const distance = parkRadius * 0.6 * (0.7 + Math.random() * 0.3); // Random distance from center
                
                x = Math.cos(angle) * distance;
                z = Math.sin(angle) * distance;
                
                // Create patch base (green area)
                const patchGeometry = new THREE.PlaneGeometry(patchSize, patchSize);
                const patchMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x2E8B57,
                    side: THREE.DoubleSide
                });
                const patch = new THREE.Mesh(patchGeometry, patchMaterial);
                patch.rotation.x = -Math.PI / 2;
                patch.position.set(x, 0.01, z);
                scene.add(patch);
                
                // Add collision box for patch (slightly larger than visual)
                const patchBox = new THREE.Box3().setFromObject(patch);
                patchBox.expandByScalar(0.5);
                obstacles.push(patchBox);
                collisionObjects.push(patch);
                flowerPatches.push(patch);
                
                // Add flowers to the patch
                const flowersCount = 5 + Math.floor(Math.random() * 10); // Random number of flowers
                const group = new THREE.Group();
                
                for (let j = 0; j < flowersCount; j++) {
                    const flowerX = (Math.random() - 0.5) * patchSize * 0.8; // Random position within patch
                    const flowerZ = (Math.random() - 0.5) * patchSize * 0.8;
                    
                    // Flower stem
                    const stemGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.8, 8);
                    const stemMaterial = new THREE.MeshStandardMaterial({ color: 0x00AA00 });
                    const stem = new THREE.Mesh(stemGeometry, stemMaterial);
                    stem.position.set(flowerX, 0.4, flowerZ);
                    group.add(stem);
                    
                    // Flower head
                    const flowerGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                    const flowerMaterial = new THREE.MeshStandardMaterial({ color: 0xFF69B4 });
                    const flower = new THREE.Mesh(flowerGeometry, flowerMaterial);
                    flower.position.set(flowerX, 0.8, flowerZ);
                    group.add(flower);
                }
                
                group.position.set(x, 0, z);
                scene.add(group);
            }
        }

        // Create dustbins around the park
        function createDustbins() {
            const dustbinCount = 4; // Number of dustbins
            
            for (let i = 0; i < dustbinCount; i++) {
                const angle = (i / dustbinCount) * Math.PI * 2; // Evenly spaced around circle
                const distance = parkRadius * 0.7; // Distance from center
                
                const x = Math.cos(angle) * distance;
                const z = Math.sin(angle) * distance;
                
                // Dustbin base
                const baseGeometry = new THREE.CylinderGeometry(0.8, 0.8, 0.2, 16);
                const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.set(x, 0.1, z);
                
                // Dustbin body
                const bodyGeometry = new THREE.CylinderGeometry(0.7, 0.8, 1, 16);
                const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.set(x, 0.8, z);
                
                // Dustbin top
                const topGeometry = new THREE.CylinderGeometry(0.75, 0.75, 0.1, 16);
                const topMaterial = new THREE.MeshStandardMaterial({ color: 0x777777 });
                const top = new THREE.Mesh(topGeometry, topMaterial);
                top.position.set(x, 1.35, z);
                
                const dustbin = new THREE.Group();
                dustbin.add(base, body, top);
                dustbin.castShadow = true;
                dustbin.receiveShadow = true;
                scene.add(dustbin);
                dustbins.push(dustbin);
                
                // Add collision box for dustbin
                const dustbinBox = new THREE.Box3().setFromObject(dustbin);
                obstacles.push(dustbinBox);
                collisionObjects.push(dustbin);
            }
        }

        // Create trees around the park
        function createTrees() {
            const treeCount = 15; // Number of trees
            
            for (let i = 0; i < treeCount; i++) {
                let x, z, attempts = 0;
                do {
                    // Find random position within park
                    const angle = Math.random() * Math.PI * 2;
                    const distance = parkRadius * 0.8 * Math.random();
                    
                    x = Math.cos(angle) * distance;
                    z = Math.sin(angle) * distance;
                    attempts++;
                } while ((!isValidPosition(x, z, []) || Math.sqrt(x*x + z*z) < 15) && attempts < 50);
                
                if (attempts < 50) {
                    const tree = createTree(x, z);
                    obstacles.push(new THREE.Box3().setFromObject(tree.trunk).expandByScalar(1.5));
                    collisionObjects.push(tree.trunk);
                }
            }
        }

        // Helper function to create a single tree
        function createTree(x, z) {
            // Tree trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.4, 2, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(x, 1, z);
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            
            // Tree leaves (top)
            const leavesGeometry = new THREE.SphereGeometry(2, 8, 8);
            const leavesMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves.position.set(x, 3.5, z);
            leaves.castShadow = true;
            leaves.receiveShadow = true;
            
            scene.add(trunk, leaves);
            return { trunk, leaves };
        }

        // Check if a position is valid (not too close to other objects)
        function isValidPosition(x, z, objects, minDistance = 10) {
            const testPos = new THREE.Vector3(x, 0, z);
            
            // Check park boundaries (circular)
            if (Math.sqrt(x*x + z*z) > parkRadius - 2) return false;
            
            // Check distance to other objects
            for (const obj of objects) {
                if (obj.position.distanceTo(testPos) < minDistance) {
                    return false;
                }
            }
            return true;
        }

        // Create an NPC character
        function createNPC(x, z, color) {
            const npcGroup = new THREE.Group();
            // Use provided color or random from npcColors
            const npcColor = color || npcColors[Math.floor(Math.random() * npcColors.length)];
            
            // NPC head
            const headGeometry = new THREE.SphereGeometry(0.4, 8, 8);
            const headMaterial = new THREE.MeshStandardMaterial({ color: npcColor });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0, 1.9, 0);
            npcGroup.add(head);
            
            // NPC torso
            const torsoGeometry = new THREE.BoxGeometry(0.7, 0.9, 0.4);
            const torsoMaterial = new THREE.MeshStandardMaterial({ color: npcColor });
            const torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
            torso.position.set(0, 1.1, 0);
            npcGroup.add(torso);
            
            // NPC legs
            const legGeometry = new THREE.BoxGeometry(0.25, 0.8, 0.25);
            const legMaterial = new THREE.MeshStandardMaterial({ color: npcColor });
            
            // Left leg
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.2, 0.4, 0);
            npcGroup.add(leftLeg);
            
            // Right leg
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.2, 0.4, 0);
            npcGroup.add(rightLeg);
            
            // Set NPC position and properties
            npcGroup.position.set(x, 0, z);
            npcGroup.castShadow = true;
            npcGroup.userData.isNPC = true;
            npcGroup.userData.color = npcColor;
            npcGroup.userData.state = "wandering"; // Current behavior state
            npcGroup.userData.throwCount = 0; // Count of throws since last rest
            npcGroup.userData.restPosition = null; // Where to rest
            npcGroup.userData.restTimer = 0; // Time remaining to rest
            
            scene.add(npcGroup);
            
            // NPC movement properties
            npcGroup.speed = 0.01 + Math.random() * 0.01; // Movement speed
            npcGroup.targetPosition = new THREE.Vector3(); // Current movement target
            npcGroup.uncollectedProjectiles = 0; // Number of uncollected projectiles
            npcGroup.maxUncollectedProjectiles = 1 + Math.floor(Math.random() * 2); // Max uncollected (1 or 2)
            
            // Method to find a new target position to move to
            npcGroup.findNewTarget = function() {
                for (let attempts = 0; attempts < 20; attempts++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 5 + Math.random() * 10;
                    
                    const newTarget = new THREE.Vector3(
                        this.position.x + Math.sin(angle) * distance,
                        0,
                        this.position.z + Math.cos(angle) * distance
                    );
                    
                    // Check park boundaries
                    if (Math.sqrt(newTarget.x*newTarget.x + newTarget.z*newTarget.z) > parkRadius - 2) continue;
                    
                    // Check path with raycasting
                    const direction = new THREE.Vector3().subVectors(newTarget, this.position).normalize();
                    const ray = new THREE.Raycaster(this.position, direction, 0, distance);
                    const intersects = ray.intersectObjects(collisionObjects);
                    
                    let pathClear = true;
                    for (const intersect of intersects) {
                        if (intersect.distance < distance) {
                            pathClear = false;
                            break;
                        }
                    }
                    
                    if (pathClear) {
                        this.targetPosition.copy(newTarget);
                        return true;
                    }
                }
                return false;
            };
            
            // Initialize first target
            npcGroup.findNewTarget();
            
            // Add collision box (slightly larger than NPC)
            npcGroup.collisionBox = new THREE.Box3().setFromObject(npcGroup);
            npcGroup.collisionBox.expandByScalar(0.5);
            
            return npcGroup;
        }

        // Adjust NPC count based on game state (but we're removing this functionality)
        function adjustNPCCount() {
            // We're keeping NPCs constant now as per requirements
            return;
        }

        // Create the player's dog character
        function createDog() {
            const dogGroup = new THREE.Group();
            const scale = 0.7; // Scale factor for dog size
            dogGroup.scale.set(scale, scale, scale);
            
            // Dog body parts
            const bodyGeometry = new THREE.BoxGeometry(1.5, 0.8, 0.8);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xA0522D }); // Brown color
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.8;
            body.castShadow = true;
            
            // Dog head
            const headGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xA0522D });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0, 1.0, 0.8); // Position in front of body
            dogGroup.add(head);
            
            // Dog legs
            const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 8);
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 }); // Darker brown
            
            // Positions for four legs
            const legs = [
                [-0.4, 0.25, 0.4], // Front left
                [0.4, 0.25, 0.4],  // Front right
                [-0.4, 0.25, -0.4], // Back left
                [0.4, 0.25, -0.4]   // Back right
            ].forEach(pos => {
                const leg = new THREE.Mesh(legGeometry, legMaterial);
                leg.position.set(...pos);
                leg.rotation.x = Math.PI / 2; // Rotate to be horizontal
                leg.castShadow = true;
                dogGroup.add(leg);
            });
            
            // Dog tail
            const tailGeometry = new THREE.CylinderGeometry(0.05, 0.1, 0.6, 8);
            const tail = new THREE.Mesh(tailGeometry, legMaterial);
            tail.position.set(-0.8, 0.8, -0.4); // Position at back
            tail.rotation.z = Math.PI / 4; // Angle the tail
            tail.castShadow = true;
            
            // Assemble dog
            dogGroup.add(body, head, tail);
            dogGroup.position.set(0, 0, 0);
            dogGroup.castShadow = true;
            dogGroup.userData.isDog = true;
            scene.add(dogGroup);
            
            // Dog movement properties
            dogGroup.speed = 0; // Current speed
            dogGroup.maxSpeed = 0.1; // Maximum speed
            dogGroup.acceleration = 0.02; // Acceleration rate
            dogGroup.deceleration = 0.05; // Deceleration rate
            dogGroup.rotationSpeed = 0.05; // Turning speed
            dogGroup.direction = new THREE.Vector3(0, 0, 1); // Facing direction
            dogGroup.velocity = new THREE.Vector3(); // Current velocity
            dogGroup.isJumping = false; // Jump state
            dogGroup.jumpHeight = 0; // Current jump height
            dogGroup.jumpVelocity = 0; // Current jump velocity
            dogGroup.collisionBox = new THREE.Box3().setFromObject(dogGroup); // Collision box
            
            return dogGroup;
        }

        // Spawn initial NPCs
        function spawnInitialNPCs() {
            const allObjects = [...collisionObjects];
            
            for (let i = 0; i < currentNPCs; i++) {
                let x, z, attempts = 0;
                do {
                    // Find random position in park
                    const angle = Math.random() * Math.PI * 2;
                    const distance = parkRadius * 0.7 * Math.random();
                    
                    x = Math.cos(angle) * distance;
                    z = Math.sin(angle) * distance;
                    attempts++;
                } while (!isValidPosition(x, z, allObjects) && attempts < 50);
                
                if (attempts < 50) {
                    // Create NPC with assigned color
                    const npc = createNPC(x, z, npcColors[i % npcColors.length]);
                    npcs.push(npc);
                    allObjects.push(npc);
                }
            }
        }

        // Spawn the player's dog
        function spawnDog() {
            const allObjects = [...collisionObjects, ...npcs];
            let x = 0, z = 0, attempts = 0;
            
            do {
                // Find random position near center
                x = Math.random() * 20 - 10;
                z = Math.random() * 20 - 10;
                attempts++;
            } while (!isValidPosition(x, z, allObjects) && attempts < 50);
            
            dog = createDog();
            dog.position.set(x, 0, z);
            
            // Game is now ready
            gameLoaded = true;
            loadingText.style.display = 'none';
        }

        // Initialize game in sequence
        function initGame() {
            // 1. Create park environment
            createPark();
            createFlowerPatches();
            createDustbins();
            createTrees();
            
            // 2. Spawn NPCs after 1 second
            setTimeout(() => {
                spawnInitialNPCs();
                
                // 3. Spawn dog after NPCs are placed
                spawnDog();
            }, 1000);
        }

        // Check for collisions with environment
        function checkCollision(objectBox) {
            // Check park boundaries
            if (!parkBoundary.containsBox(objectBox)) return true;
            
            // Check circular boundary
            const center = objectBox.getCenter(new THREE.Vector3());
            if (Math.sqrt(center.x*center.x + center.z*center.z) > parkRadius - 1) return true;
            
            // Check obstacles
            for (const obstacle of obstacles) {
                if (obstacle.intersectsBox(objectBox)) return true;
            }
            return false;
        }

        // Create a projectile (ball)
        function createProjectile(position, direction, color) {
            const geometry = new THREE.SphereGeometry(0.3, 16, 16);
            const material = new THREE.MeshStandardMaterial({ 
                color: color,
                roughness: 0.8,
                metalness: 0.1
            });
            
            const projectile = new THREE.Mesh(geometry, material);
            projectile.position.copy(position);
            projectile.userData.color = color; // Store color for identification
            
            // Projectile motion properties
            projectile.velocity = direction.clone().normalize().multiplyScalar(0.1);
            projectile.velocity.y = 0.2; // Initial upward velocity
            projectile.gravity = -0.02; // Gravity effect
            projectile.stuck = false; // Has it hit the ground?
            projectile.collected = false; // Has it been collected by dog?
            
            scene.add(projectile);
            projectiles.push(projectile);
            return projectile;
        }

        // Show floating score popup at a position
        function showScorePopup(score, position) {
            const popup = document.createElement('div');
            popup.className = 'score-popup';
            popup.textContent = `+${score}`;
            
            // Convert 3D position to screen coordinates
            const vector = position.clone().project(camera);
            vector.x = (vector.x * 0.5 + 0.5) * window.innerWidth;
            vector.y = (-(vector.y * 0.5) + 0.5) * window.innerHeight;
            
            popup.style.left = `${vector.x}px`;
            popup.style.top = `${vector.y}px`;
            document.body.appendChild(popup);
            
            // Remove after animation completes
            setTimeout(() => {
                popup.remove();
            }, 1000);
        }

        // Check if dog collects any projectiles
        function checkProjectileCollection() {
            const dogBox = dog.collisionBox;
            
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                const pBox = new THREE.Box3().setFromObject(p);
                
                if (dogBox.intersectsBox(pBox) && !p.collected) {
                    // Check if dog can carry more items
                    if (withDogCount >= maxWithDog) {
                        continue;
                    }
                    
                    p.collected = true;
                    scene.remove(p);
                    projectiles.splice(i, 1);
                    
                    // Add to carried projectiles
                    carriedProjectiles.push(p);
                    withDogCount++;
                    withDogElement.textContent = `With Dog: ${withDogCount}/${maxWithDog}`;
                    
                    // Update color counts display
                    colorCounts[p.userData.color]++;
                    updateColorCounts();
                    
                    // Decrement uncollected count for owner NPC if exists
                    if (p.owner && p.owner.uncollectedProjectiles > 0) {
                        p.owner.uncollectedProjectiles--;
                    }
                }
            }
        }

        // Return projectiles to owners or trash bins
        function returnProjectilesToOwners() {
            if (withDogCount === 0) return;
            
            // First check for trash (white projectiles)
            for (let i = carriedProjectiles.length - 1; i >= 0; i--) {
                const projectile = carriedProjectiles[i];
                
                // Check if it's trash (white) and near a dustbin
                if (projectile.userData.color === 0xFFFFFF) {
                    for (const dustbin of dustbins) {
                        const dustbinPos = dustbin.position.clone();
                        dustbinPos.y = 0; // Ignore height difference
                        const dogPos = dog.position.clone();
                        dogPos.y = 0;
                        
                        if (dogPos.distanceTo(dustbinPos) < 3) {
                            // Return to dustbin successful - add points
                            score += 10; // More points for trash
                            scoreElement.textContent = `Score: ${score}`;
                            showScorePopup(10, dog.position);
                            
                            // Remove from carried projectiles
                            carriedProjectiles.splice(i, 1);
                            withDogCount--;
                            withDogElement.textContent = `With Dog: ${withDogCount}/${maxWithDog}`;
                            
                            // Update color counts
                            colorCounts[projectile.userData.color]--;
                            updateColorCounts();
                            
                            break;
                        }
                    }
                }
            }
            
            // Then check for regular projectiles to return to NPCs
            for (let i = carriedProjectiles.length - 1; i >= 0; i--) {
                const projectile = carriedProjectiles[i];
                let closestNPC = null;
                let closestDistance = Infinity;
                
                // Find closest NPC of matching color
                for (const npc of npcs) {
                    if (npc.userData.color === projectile.userData.color) {
                        const distance = npc.position.distanceTo(dog.position);
                        if (distance < closestDistance) {
                            closestDistance = distance;
                            closestNPC = npc;
                        }
                    }
                }
                
                // If close enough to matching NPC, return the projectile
                if (closestNPC && closestDistance < 5) {
                    // Return successful - add points
                    score += 5;
                    scoreElement.textContent = `Score: ${score}`;
                    showScorePopup(5, dog.position);
                    
                    // Remove from carried projectiles
                    carriedProjectiles.splice(i, 1);
                    withDogCount--;
                    withDogElement.textContent = `With Dog: ${withDogCount}/${maxWithDog}`;
                    
                    // Update color counts
                    colorCounts[projectile.userData.color]--;
                    updateColorCounts();
                    
                    // Wake up NPC if it was resting
                    if (closestNPC.userData.state === "resting") {
                        closestNPC.userData.state = "wandering";
                        closestNPC.userData.restTimer = 0;
                        closestNPC.findNewTarget();
                    }
                }
            }
        }

        // Input handling
        const keys = {
            w: false, a: false, s: false, d: false, ' ': false,
            e: false // Key for returning items
        };
        
        // Key down event listener
        window.addEventListener('keydown', (event) => {
            if (!gameLoaded) return;
            const key = event.key.toLowerCase();
            if (keys.hasOwnProperty(key)) keys[key] = true;
            
            // Return items when 'E' is pressed
            if (key === 'e') {
                returnProjectilesToOwners();
            }
        });
        
        // Key up event listener
        window.addEventListener('keyup', (event) => {
            if (!gameLoaded) return;
            const key = event.key.toLowerCase();
            if (keys.hasOwnProperty(key)) keys[key] = false;
        });

        // Animation loop - runs every frame
        let lastTime = 0;
        function animate(time) {
            requestAnimationFrame(animate);
            const deltaTime = time - lastTime;
            lastTime = time;
            
            if (!gameLoaded) return;
            
            // Dog movement based on input
            if (keys.w) dog.speed = Math.min(dog.speed + dog.acceleration, dog.maxSpeed);
            else if (keys.s) dog.speed = Math.max(dog.speed - dog.acceleration, -dog.maxSpeed * 0.5);
            else {
                // Decelerate when no key pressed
                if (dog.speed > 0) dog.speed = Math.max(dog.speed - dog.deceleration, 0);
                else if (dog.speed < 0) dog.speed = Math.min(dog.speed + dog.deceleration, 0);
            }
            
            // Dog rotation
            if (keys.a) {
                dog.rotation.y += dog.rotationSpeed;
                dog.direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), dog.rotationSpeed);
            }
            if (keys.d) {
                dog.rotation.y -= dog.rotationSpeed;
                dog.direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), -dog.rotationSpeed);
            }
            
            // Dog jumping
            if (keys[' '] && !dog.isJumping) {
                dog.isJumping = true;
                dog.jumpVelocity = 0.25;
            }
            
            // Apply gravity to jump
            if (dog.isJumping) {
                dog.jumpVelocity -= 0.02;
                dog.jumpHeight += dog.jumpVelocity;
                if (dog.jumpHeight <= 0) {
                    dog.jumpHeight = 0;
                    dog.isJumping = false;
                    dog.jumpVelocity = 0;
                }
            }
            
            // Update dog position and check collisions
            dog.velocity.copy(dog.direction).multiplyScalar(dog.speed);
            const oldPosition = dog.position.clone();
            dog.position.add(dog.velocity);
            dog.position.y = dog.jumpHeight;
            dog.collisionBox.setFromObject(dog);
            
            if (checkCollision(dog.collisionBox)) {
                dog.position.copy(oldPosition);
                dog.speed = 0;
                dog.collisionBox.setFromObject(dog);
            }
            
            // NPC movement and behavior
            for (const npc of npcs) {
                // Update collision box
                npc.collisionBox.setFromObject(npc);
                
                if (npc.userData.state === "wandering") {
                    // Movement toward target
                    if (npc.targetPosition) {
                        const direction = new THREE.Vector3().subVectors(npc.targetPosition, npc.position).normalize();
                        const distance = npc.position.distanceTo(npc.targetPosition);
                        
                        if (distance > 0.5) {
                            const oldPos = npc.position.clone();
                            npc.position.add(direction.multiplyScalar(Math.min(npc.speed, distance)));
                            npc.rotation.y = Math.atan2(-direction.x, -direction.z);
                            
                            // Check for collisions
                            if (checkCollision(npc.collisionBox)) {
                                npc.position.copy(oldPos);
                                npc.findNewTarget();
                            }
                        } else {
                            npc.findNewTarget();
                        }
                    }
                    
                    // Random chance to throw projectile (including white trash)
                    if (npc.uncollectedProjectiles < npc.maxUncollectedProjectiles && Math.random() < 0.003) {
                        const toDog = new THREE.Vector3().subVectors(dog.position, npc.position).normalize();
                        // Randomly choose between normal color or white (trash)
                        const throwColor = Math.random() < 0.2 ? 0xFFFFFF : npc.userData.color;
                        const projectile = createProjectile(
                            npc.position.clone().add(new THREE.Vector3(0, 1.5, 0)), 
                            toDog, 
                            throwColor
                        );
                        projectile.owner = npc;
                        npc.uncollectedProjectiles++;
                        npc.userData.throwCount++;
                        
                        // After throwing twice, find a rest spot
                        if (npc.userData.throwCount >= 2) {
                            npc.userData.state = "seekingRest";
                            npc.userData.throwCount = 0;
                            
                            // Find a rest position
                            for (let attempts = 0; attempts < 20; attempts++) {
                                const angle = Math.random() * Math.PI * 2;
                                const distance = 5 + Math.random() * 10;
                                
                                const restPos = new THREE.Vector3(
                                    npc.position.x + Math.sin(angle) * distance,
                                    0,
                                    npc.position.z + Math.cos(angle) * distance
                                );
                                
                                // Check park boundaries
                                if (Math.sqrt(restPos.x*restPos.x + restPos.z*restPos.z) > parkRadius - 2) continue;
                                
                                // Check path with raycasting
                                const direction = new THREE.Vector3().subVectors(restPos, npc.position).normalize();
                                const ray = new THREE.Raycaster(npc.position, direction, 0, distance);
                                const intersects = ray.intersectObjects(collisionObjects);
                                
                                let pathClear = true;
                                for (const intersect of intersects) {
                                    if (intersect.distance < distance) {
                                        pathClear = false;
                                        break;
                                    }
                                }
                                
                                if (pathClear) {
                                    npc.userData.restPosition = restPos;
                                    npc.targetPosition.copy(restPos);
                                    break;
                                }
                            }
                        }
                    }
                } 
                else if (npc.userData.state === "seekingRest") {
                    // Move to rest position
                    if (npc.userData.restPosition) {
                        const direction = new THREE.Vector3().subVectors(npc.userData.restPosition, npc.position).normalize();
                        const distance = npc.position.distanceTo(npc.userData.restPosition);
                        
                        if (distance > 0.5) {
                            const oldPos = npc.position.clone();
                            npc.position.add(direction.multiplyScalar(Math.min(npc.speed, distance)));
                            npc.rotation.y = Math.atan2(-direction.x, -direction.z);
                            
                            if (checkCollision(npc.collisionBox)) {
                                npc.position.copy(oldPos);
                                npc.userData.state = "wandering";
                                npc.findNewTarget();
                            }
                        } else {
                            // Reached rest position
                            npc.userData.state = "resting";
                            npc.userData.restTimer = 5000 + Math.random() * 10000; // 5-15 seconds
                        }
                    } else {
                        npc.userData.state = "wandering";
                        npc.findNewTarget();
                    }
                }
                else if (npc.userData.state === "resting") {
                    // Count down rest timer
                    npc.userData.restTimer -= deltaTime;
                    if (npc.userData.restTimer <= 0) {
                        npc.userData.state = "wandering";
                        npc.findNewTarget();
                    }
                }
            }
            
            // Update projectiles with parabolic motion
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                
                if (!p.stuck) {
                    // Apply gravity
                    p.velocity.y += p.gravity;
                    
                    // Update position
                    p.position.x += p.velocity.x;
                    p.position.y += p.velocity.y;
                    p.position.z += p.velocity.z;
                    
                    // Check if projectile hit the ground
                    if (p.position.y <= 0.2) {
                        p.position.y = 0.2;
                        p.stuck = true;
                    }
                }
            }
            
            // Check for projectile collection by dog
            checkProjectileCollection();
            
            // Update camera position and render scene
            updateCameraPosition();
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start the game
        initGame();
        animate();
    </script>
</body>
</html>